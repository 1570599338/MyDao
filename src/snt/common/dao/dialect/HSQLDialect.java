//$Id: HSQLDialect.java,v 1.36 2005/11/27 22:42:03 oneovthafew Exp $
package snt.common.dao.dialect;

import java.sql.Types;

/**
 * An SQL dialect compatible with HSQLDB (Hypersonic SQL).
 * <p/>
 * Note this version supports HSQLDB version 1.8 and higher, only.
 *
 * @author Christoph Sturm, Phillip Baird
 */
public class HSQLDialect extends Dialect {

	private boolean schemaSupport;

	public HSQLDialect() {
		super();
		registerColumnType( Types.BIGINT, "bigint" );
		registerColumnType( Types.BINARY, "binary" );
		registerColumnType( Types.BIT, "bit" );
		registerColumnType( Types.CHAR, "char(1)" );
		registerColumnType( Types.DATE, "date" );
		registerColumnType( Types.DECIMAL, "decimal" );
		registerColumnType( Types.DOUBLE, "double" );
		registerColumnType( Types.FLOAT, "float" );
		registerColumnType( Types.INTEGER, "integer" );
		registerColumnType( Types.LONGVARBINARY, "longvarbinary" );
		registerColumnType( Types.LONGVARCHAR, "longvarchar" );
		registerColumnType( Types.SMALLINT, "smallint" );
		registerColumnType( Types.TINYINT, "tinyint" );
		registerColumnType( Types.TIME, "time" );
		registerColumnType( Types.TIMESTAMP, "timestamp" );
		registerColumnType( Types.VARCHAR, "varchar($l)" );
		registerColumnType( Types.VARBINARY, "varbinary($l)" );
		registerColumnType( Types.NUMERIC, "numeric" );
		//HSQL has no Blob/Clob support .... but just put these here for now!
		registerColumnType( Types.BLOB, "longvarbinary" );
		registerColumnType( Types.CLOB, "longvarchar" );

		getDefaultProperties().setProperty( "STATEMENT_BATCH_SIZE", DEFAULT_BATCH_SIZE );

		try {
			// Does present HSQLDB Database class support schemas?
			// yuck! Perhaps we should think about a new dialect?  Especially
			// if more things are going to break back-compat moving forward
			Class.forName( "org.hsqldb.Database" ).getDeclaredField( "schemaManager" );
			schemaSupport = true;
		}
		catch (Throwable t) {
			schemaSupport = false;
		}
	}

	public String getAddColumnString() {
		return "add column";
	}

	public boolean supportsIdentityColumns() {
		return true;
	}

	public String getIdentityColumnString() {
		return "generated by default as identity (start with 1)"; //not null is implicit
	}

	public String getIdentitySelectString() {
		return "call identity()";
	}

	public String getIdentityInsertString() {
		return "null";
	}

	public String getForUpdateString() {
		return "";
	}

	public boolean supportsUnique() {
		return false;
	}

	public boolean supportsLimit() {
		return true;
	}

	public String getLimitString(String sql, boolean hasOffset) {
		return new StringBuffer( sql.length() + 10 )
				.append( sql )
				.insert( sql.toLowerCase().indexOf( "select" ) + 6, hasOffset ? " limit ? ?" : " top ?" )
				.toString();
	}

	public boolean bindLimitParametersFirst() {
		return true;
	}

	public boolean supportsIfExistsAfterTableName() {
		return true;
	}

	public boolean supportsColumnCheck() {
		return false;
	}

	public String[] getCreateSequenceStrings(String sequenceName) {
		return new String[] {
				"create table dual_" + sequenceName + " (zero integer)",
				"insert into dual_" + sequenceName + " values (0)",
				"create sequence " + sequenceName + " start with 1"
		};
	}

	public String[] getDropSequenceStrings(String sequenceName) {
		return new String[] {
				"drop table dual_" + sequenceName + " if exists",
		        "drop sequence " + sequenceName
		};
	}

	public String getSelectSequenceNextValString(String sequenceName) {
		return "next value for " + sequenceName;
	}

	public String getSequenceNextValString(String sequenceName) {
		return "select next value for " + sequenceName + " from dual_" + sequenceName;
	}

	public String getQuerySequencesString() {
		if ( schemaSupport ) {
			return "select sequence_name from information_schema.system_sequences";
		}
		else {
			return "select sequence_name from system_sequences";
		}
	}

	public boolean supportsSequences() {
		return true;
	}

	/**
	 * HSQL does not really support temp tables; just take advantage of the
	 * fact that it is a single user db...
	 */
	public boolean supportsTemporaryTables() {
		return true;
	}

	public boolean supportsCurrentTimestampSelection() {
		return false;
	}

}
